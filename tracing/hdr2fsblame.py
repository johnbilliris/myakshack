#!/usr/bin/env python3
# Copyright (c) 2024, Ping He.
# License: MIT
"""Generate a vfsblame program by given header in stdin

To generate fsblame, use::

    python3 hdr2fsblame.py <{linux-src-root}/include/linux/fs.h

"""
import re
import time
FUNCPATTERN = re.compile(r'^([\w_]+ \*?)+(?P<fname>vfs_[\w_]+)\((?P<arglist>[^)]+)\);', re.M)
ARGPATTERN = re.compile(r'(const )?struct (?P<type>dentry|file|path|inode) \*')
NOW = time.asctime()
HDR_BLOCK = r'''
#!/usr/bin/env bpftrace
''' \
f'/* automatically generated by hdr2fsblame.py at {NOW} */' \
r'''
/*
 * fsblame    count vfs calls and sum of latency to a given filesystem by
 *            provided magic
 *
 * This works by tracing all potential vfs functions
 *
 * USAGE: fsblame.bt <magic>
 * Example:
 * for cifs: fsblame.bt 4283649346. (CIFS_MAGIC_NUMBER, 0xFF534D42)
 * for ext4: fsblame.bt 61267. (EXT4_SUPER_MAGIC, 0xEF53)
 */
#include <linux/fs.h>

BEGIN
{
    printf("Tracing VFS calls for %x ... Hit Ctrl-C to end.\n", $1);
}

interval:s:10
{
    time();
    print(@count);
    clear(@count);
    print(@latsum);
    clear(@latsum);
    print(@lathist);
    clear(@lathist);
}
'''

CONDS = {
    'file': '(((struct file *)arg%d)->f_inode->i_sb->s_magic == (uint64) $1)',
    'path': '(((struct path *)arg%d)->dentry->d_sb->s_magic == (uint64) $1)',
    'dentry': '(((struct dentry *)arg%d)->d_sb->s_magic == (uint64) $1)',
    'inode': '(((struct inode *)arg%d)->i_sb->s_magic == (uint64) $1)',
}
KPROBE_BLOCK = '''
{
    if (%s) {
        @count[func, comm]++;
        @start[tid] = nsecs;
        @func[tid] = func;
        @comm[tid] = comm;
    }
}
'''
KRETPROBE_BLOCK = '''
/ @start[tid] /
{
    $lat = nsecs - @start[tid];
    @latsum[@func[tid], @comm[tid]] += $lat;
    @lathist[@func[tid], @comm[tid]] = hist($lat);
    delete(@start[tid]);
    delete(@func[tid]);
    delete(@comm[tid]);
}
'''

def main(header):
    patterns = {}
    for m in FUNCPATTERN.finditer(header):
        d = m.groupdict()
        args = d['arglist'].split(',')
        found = []
        for i, arg in enumerate(args):
            am = ARGPATTERN.match(arg.strip())
            if am:
                found.append((i, am.groupdict()['type']))

        pattern = tuple(found)
        if not pattern:
            continue
        patterns.setdefault(pattern, [])
        patterns[pattern].append(d['fname'])

    print(HDR_BLOCK)
    for pattern, funcs in patterns.items():
        print(',\n'.join('kprobe:' + f + suffix for f in funcs for suffix in ('', '.*')), end='')
        conditions = ' || '.join(CONDS[kind] % i for i, kind in pattern)
        print(KPROBE_BLOCK % conditions, end='')

    allkretprobe = ['kretprobe:' + f + suffix for _, funcs in patterns.items()
                    for f in funcs for suffix in ('', '.*')]
    print(',\n'.join(allkretprobe), end='')
    print(KRETPROBE_BLOCK)

if __name__ == '__main__':
    import sys
    main(sys.stdin.read())
